"""
Creates the overview markdown files.
"""
import bibtexparser
import os
from typing import TextIO

from markdown import entry_to_markdown
import names


def make_overview(document_structure: dict | list, grouped_entries: dict,
                  title: str, outfile: str):
    """
    Creates an overview filed formatted as markdown.
    The `document_structure` dictates the structure of the document.
    It can either be a list of categories, which corresponds to sections
    on the same level. Or it can be a dictionary, where the keys are
    the respective categories as sections on the same level, and their
    values populate the sections.
    A given category can be a tuple. In this case, all entries correesponding
    to either of the groups will be included in the section. The first entry
    in the tuple is used for naming the section.

    The `grouped_entries` is a dictionary where the keys are the categories
    mapping onto the entries that belong to the category.

    The `title` is the title of the document. It will be printed as the first
    line as main heading.

    The `outfile` is the file to which the output will be written.
    """
    with open(outfile, 'w') as out:
        out.write(f'# {title}\n\n')

        out.write('<!-- This file is automatically generated. Do not edit. -->\n\n')

        _make_toc(document_structure, 0, out)
        out.write('\n')

        _write_sections(document_structure, grouped_entries, 2, out)


def _make_toc(doc_structure: dict | list, nesting_depth: int, out: TextIO):
    nesting_prefix = '  ' * nesting_depth
    for section in doc_structure:
        if not isinstance(section, tuple):
            section = (section,)

        section_name = names.translation[section[0]]
        toc_link = _github_toc_link(section_name)

        out.write(f'{nesting_prefix}* [{section_name}](#{toc_link})\n')

        if isinstance(doc_structure, dict):
            _make_toc(doc_structure[section], nesting_depth + 1, out)


def _github_toc_link(section_name: str) -> str:
    """
    Turns string to lower case, replaces spaces with dashes,
    and removes non-alphanumeric characters.
    """
    section_name = section_name.lower().replace(' ', '-')
    section_name = ''.join(c for c in section_name if c.isalnum() or c == '-')
    return section_name


def _write_sections(section_structure: dict | list, grouped_entries: dict,
                    heading_level: int, out: TextIO):
    heading_prefix = '#' * heading_level

    # Nested dictionaries correspond to nested sections.
    has_subsections = isinstance(section_structure, dict)

    for section in section_structure:
        # A section can be a tuple or a string; we unify this to all tuples.
        if not isinstance(section, tuple):
            section = (section,)

        # The first entry in the tuple is the name of the section.
        section_name = names.translation[section[0]]

        out.write(f'{heading_prefix} {section_name}\n\n')

        if has_subsections:
            _write_sections(section_structure[section], heading_level + 1, out)
        else:
            for category in section:
                entries = grouped_entries.get(category, [])
                for entry in entries:
                    out.write('* ' + entry_to_markdown(entry))
                    out.write('\n')
            out.write('\n')


if __name__ == '__main__':
    with open('database.bib') as f:
        bib = bibtexparser.load(f)

    # Sort the entries by group.
    group_entries = {}
    for entry in bib.entries:
        groups = entry.get('groups', '').split(',')
        for group in groups:
            group = group.strip()
            group_entries.setdefault(group, []).append(entry)

    ai_groups = [
        ('trees', 'ai-mul-trees'),
        ('randomforest', 'ai-mul-randomforest'),
        ('svm', 'ai-mul-svm'),
        ('knn', 'ai-mul-knn'),
        'ai-mul-lr',
        ('neuralnetworks', 'ai-mul-neuralnetworks'),
        'reinforcement-learning',
        ('genetic', 'ai-mul-genetic'),
        ('nlp', 'ai-mul-llm'),
        'automatonlearning',
        'baysianinference',
        ('clustering', 'ai-mul-clustering'),
        ('datamining', 'ai-mul-datamining'),
        'ai-mul-naive',
        # 'ai-multiple',
        'ai-custom',
        'ai-other',
    ]

    fm_groups = [
        'sat',
        'smt',
        'tp',
        'modelchecking',
        'synthesis',
        'other',
    ]

    os.makedirs('overview', exist_ok=True)
    make_overview(ai_groups, group_entries,
                  'Overview of used AI techniques',
                  'overview/ai-techniques.md')
    make_overview(fm_groups, group_entries,
                  'Overview of used FM techniques',
                  'overview/fm-techniques.md')
